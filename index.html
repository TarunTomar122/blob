<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Marching squares</title>
    <!-- MOBILE––––––––––––––––––––––– -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
    <!-- CSS––––––––––––––––––––––– -->
    <link rel="stylesheet" href="css/normalize.css">
    <link rel="stylesheet" href="css/skeleton.css">
    <link rel="stylesheet" href="css/darkskelleton.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" type="image/png" href="images/favicon.png">

  </head>
  <body>
    <!-- detect color scheme -->
    <script type="text/javascript">
      var secondary = "#F00"
      var primary = "#333"

      //set the colorscheme
      if (window.matchMedia) {
        window.matchMedia("(prefers-color-scheme: dark)").addListener(e => {
          primary = e.matches
            ? "#d3d7cf"
            : "#333";
          console.log("theme change detected, setting color to", primary);
        });
        if (window.matchMedia("(prefers-color-scheme: dark)").matches) 
          primary = "#d3d7cf";
        }
    </script>

    <!-- header and intro text -->
    <div class="container">
      <div class="row" style="margin-top: 20%">
        <div class="twelve column">
          <h2>Marching Squares</h2>
          <p>An implementation of the marching squares algorithm to distract me from the upcoming exams. Scroll down to see an explanation of how the algorithm works, or just play around with the finished demo at the top of the page.</p>
        </div>
      </div>

      <!-- the large main canvas -->
      <div class="row">
        <div class="twelve column">
          <canvas id="canvas" class="u-full-width" width="960" height="960"></canvas>
        </div>
      </div>

      <!-- buttons and sliders for the main demo -->
      <div class="row">
        <div class="one-half column">
          <input id="resolution" type="range" min="5" step="1" max="50" value="10" class="slider" oninput="m.rez = parseInt(this.value); m.generateMap(); document.getElementById('resolutiono').textContent=this.value">
          <label for="resolution" class="u-pull-left">resolution</label>
          <output id="resolutiono" class="u-pull-right" name="result">10</output class="u-pull-right">
        </div>
        <div class="one-half column">
          <button type="button" class="u-full-width" name="button" onclick="m.interpolation=!m.interpolation; this.textContent = m.interpolation?'interpolation on':'interpolation off'">interpolation on</button>
        </div>
      </div>

      <!-- the explanation section -->
      <div class="row" style="margin-top: 20%">
        <div class="twelve column">
          <h4>What is this?</h4>
          <p>This is an implementation of the
            <a href="www.wikipedia.org/wiki/Marching_squares">marching squares algorithm</a>. It's point is to draw contours around regions of scalar values, e.g. height lines on maps or transparency masks. Here's an overview of how it works:
          </div>
        </div>

        <div class="row">
          <div class="one-half column">
            <h5>1. Create some data</h5>
            <p>First we create some data to draw contours around. In my case the values on the grid are the cumulative distances from these bouncing balls, but you could use any type of scalar field, like an image or height map.</p>
          </div>
          <div class="one-half column">
            <canvas id="gridValuesDemo" class="u-full-width" width="460" height="460"></canvas>
          </div>
        </div>
        <hr>

        <div class="row">
          <div class="one-half column">
            <h5>2. Fill a single cell</h5>
            <p>Since there's a finite number of possible corner configurations, we can explicitly specify cases for all of them. In the case of rectangular 2D grids like here, these are all the possible configurations and the lines that will be drawn for each
              case. In the corner of each cell you can see the value of that "corner".
              <br><br>
              At first we just want to know if this value is above or below a certain threshold, (in our case one) to draw lines accordingly.
            </p>
          </div>
          <div class="one-half column">
            <canvas id="gridElementTypes" class="u-full-width" width="460" height="460"></canvas>
          </div>
        </div>
        <hr>

        <div class="row">
          <div class="twelve column">
            <h5>3. Fill all cells</h5>
            <p>Now that we have decided, what sould happen with each individual cell, we can iterate through all of them and get a contour plot! Right now, the contours are still a bit blocky, but we can improve that by simply increasing the resolution.
            </p>
          </div>
        </div>
        <div class="row">
          <div class="one-half column">
            <canvas id="coarseNoInterp" class="u-full-width" width="460" height="460"></canvas>
          </div>
          <div class="one-half column">
            <canvas id="noInterp" class="u-full-width" width="460" height="460"></canvas>
          </div>
        </div>
        <hr>

        <div class="row">
          <div class="twelve column">
            <h5>4. Linear interpolation</h5>
            <p>The final step is to smooth out the lines, by adjusting their position. For that, we linearly interpolate our threshold value between the two adjacent corner values. For example with my threshold value of 1, if one corner point has a value of 0.5
              and The adjacent corner has a value of 1.5, the line segment will be placed exactly in the middle. If the corners would be 0.5 and 3, the line would be placed a lot closer to the value it's closer to. The linear interpolation for a threshold of one
              is given by the following formula:
              <br>
              <br>
              With x being the left corner value and y the right.
              <br>
              <code>f(x, y)(1 - x) / (y - x)</code>
              <br>f(x,y) then gives us a percentage, where to place our line endpoint.
              <br>
              <br>
              When we apply that, The resolting contours look like this:</p>
          </div>
        </div>
        <div class="row">
          <div class="one-half column">
            <canvas id="interpolatedDemo" class="u-full-width" width="460" height="460"></canvas>
          </div>
          <div class="one-half column">
            <canvas id="highResDemo" class="u-full-width" width="460" height="460"></canvas>
          </div>
        </div>
        <hr>
        <div class="row" style="margin-bottom:10%;">
          <div class="twelve column">
            <h5>Resources:</h5>
            <p>

              If you still want to learn more about this algorithm, check out
              <a href="http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares/">Jamie Wong's blogpost</a>
              <br>
              <a href="www.wikipedia.org/wiki/Marching_squares">The Wikipedia page</a>

              or<br>
              <a href="https://github.com/missing-user/marching_squares">my code</a>
              for this page on github.

            </p>
          </div>
        </div>

      </div>
    </div>

    <script type="text/javascript" src="scripts/script_instanced.js"></script>
    <script type="text/javascript" src="scripts/individualElements.js"></script>

    <script type="text/javascript">

      m = new MarchingSquares("canvas", {
        stepFunc() {
          this.moveCircles();
          this.updateGridPoints();
          this.drawLines();
          this.drawPoints();
        }
      })

      coarseNoInterp = new MarchingSquares("gridValuesDemo", {
        resolution: 50,
        interpolation: false,
        circleCount: 5,
        circleRadius: 80,
        stepFunc() {
          this.moveCircles();
          this.updateGridPoints();
          this.drawCircles();
          this.drawPoints();
        }
      })

      noInterp = new MarchingSquares("coarseNoInterp", {
        resolution: 50,
        circleCount: 5,
        interpolation: false,
        circleRadius: 80
      })
      noInterp = new MarchingSquares("noInterp", {
        resolution: 10,
        circleCount: 5,
        interpolation: false
      })
      highResDemo = new MarchingSquares("highResDemo", {
        resolution: 10,
        circleCount: 8
      })
      interpolatedDemo = new MarchingSquares("interpolatedDemo", {
        resolution: 50,
        circleCount: 5,
        circleRadius: 80
      })
    </script>
  </body>
</html>